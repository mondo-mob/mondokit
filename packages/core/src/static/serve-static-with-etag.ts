import * as path from "path";
import { Handler } from "express";
import { createLogger } from "../logging/logging.js";
import { fetchFileList, generateHash, pathExists } from "./utils.js";

const HASH_UNSET = "HASH_UNSET";

/**
 * Static serving middleware that sends md5 hash etags as a workaround for GAE being incompatible
 * with weak etags generated by express.static middleware.
 *
 * - On initialisation a list of all valid files is generated
 * - On first request for each file the md5 hash is generated and then cached for later use
 *
 * This is only intended to serve files like index.html and manifest.json that cannot
 * be served by the built in GAE static file handlers:
 * (https://cloud.google.com/appengine/docs/standard/nodejs/serving-static-files).
 *
 * @example
 * app.use(serveStaticWithEtag(`${__dirname}/public`))
 */
export interface StaticEtagOptions {
  ignorePaths?: string[];
  quiet?: boolean;
}
export const serveStaticWithEtag = (
  root: string,
  { ignorePaths = [], quiet = false }: StaticEtagOptions = {},
): Handler => {
  const logger = createLogger("serveStaticWithEtag");
  const rootFolder = path.resolve(root);
  const validFiles: Record<string, string> = {};

  if (!pathExists(rootFolder)) {
    logger.warn(`Requested static folder ${rootFolder} does not exist - cannot serve files`);
    return (req, res, next) => next();
  }

  const initFilesPromise = fetchFileList(rootFolder).then((allFiles) => {
    allFiles
      .filter((file) => !ignorePaths.some((path) => file.startsWith(path)))
      .forEach((file) => (validFiles[file] = HASH_UNSET));
    if (!quiet) {
      logger.info("Serving static files: ", Object.keys(validFiles));
    }
  });

  return async (req, res, next) => {
    await initFilesPromise;
    const requestPath = path.join(req.baseUrl, req.path);
    const fullFilePath = path.join(rootFolder, requestPath);

    if (validFiles[requestPath]) {
      if (validFiles[requestPath] === HASH_UNSET) {
        if (!quiet) {
          logger.debug(`Generating md5 hash for file ${fullFilePath}`);
        }
        validFiles[requestPath] = await generateHash(fullFilePath);
      }

      const etag = `"${validFiles[requestPath]}"`;
      if (!quiet) {
        logger.info(`Sending file ${fullFilePath} with etag ${etag}`);
      }
      return res.sendFile(fullFilePath, { headers: { etag }, lastModified: false }, (err) => {
        return err ? next(err) : next();
      });
    }

    next();
  };
};
